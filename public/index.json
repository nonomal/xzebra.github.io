[{"categories":["engine"],"contents":"Lighting gives games a more professional look. I wanted to introduce a simple lighting system to light blocks and entities. The lighting ideas are mostly based on the game Starbound.\nBackground I have very little knowledge about computer graphics and shaders and had to find an easy method for lighting tiles depending on light propagation; I found two resources.\nThe first one is a very explanatory blog post about how light diffusion works and some tricks to achieve it. But I couldn’t think of implementing it with just that information.\nThen, I saw the second one. A video explaining how in a very simple way you could create a light map and then plot the light on top of the drawings without using shaders.\nSolution Overview Light map The video shows a very CPU intensive way of calculating color mixes and graphics logic that could be sped up by relying on the GPU. This made me thought about actually doing a lighting map as a texture, and rely on the GPU for all the mixing and blurring.\nOnce calculated the light map, we need to plot it to the screen. To do so, we need to generate a new texture and render all the tile lights. To apply the lights, we will use the blend multiply mode, so black tiles will be render black and white tiles should be render as normal. The more dark the tile in the light map, the darker it will look.\nLight propagation The main problem to solve was how to propagate light. As both resources mention, one of the best ways to simulate light propagation is by using BFS, as it reduces considerably the number of tiles repeated (not like DFS). Also, it is a very realistic approach as light tends to propagate like a fluid (instead of flowing, bouncing on surfaces). BFS achieves this realistic effect as it can simulate a fluid (color) flow by reducing the color intensity on each step.\nThis effect looked blocky at first, because the texture I was drawing the lights to was the real size of the map. I tried to use multiple shaders to try to blur the shadows’ transitions, but they still looked blocky.\nSo I came up with the solution of relying on the GPU again. When you resize a texture, you can do it with a nearest neighbour mode to keep the pixel-ness of the texture, but it can also be used the opposite way. One of the best ways to get a very neat blur on a texture is by scaling it with a linear mode.\n Make sure to enable clamp mode when you resize the texture, or there could be artifacts on the drawing.  Once I came up with this, I changed the light map texture size to be 1 tile - 1 pixel. That way, when being resized, the lights will smooth themselves and we would use less resources to keep the texture stored and draw into it. The result is the way I expected lights to be.\nLight diffusion Wait… The second picture looks so much more realistic. How is that possible?\nWell, a very important step to achieve a realistic feel in your lighting system comes from how well you diffuse light. Light diffusion is a natural phenomena that is easy to contemplate, just turn a light in the middle of a room; not all the room will be lighted the same way.\nLight also has some obvious problem to pass through objects that are not transparent. It also has some kind of “friction” (not the best term but it does the job).\nThis friction or drop-off can be modeled such as the light loses strength when propagating (mentioned in the previous part) and, when it passes through a block, it increases a lot.\nIntensity of lights We got a very simple lighting system working. But it shouldn’t be very hard to implement different light properties. In this example, we will be implementing light intensity.\nLight intensity (or at least how I called) is the property of light to expand more. A very intense light may light a whole stadium, but a low intensity light may not be able to even light your hand. This is a cool property to implement in order to have glowing blocks of all kinds.\nLet’s think about magma or lava blocks. Lava emits light, enough to light its surroundings. But magma is rocks and lava mixed, so it should emit a timid light. This is where light intensity concept comes.\nBy modifying the lighting system to propagate the original light’s intensity in each step of the BFS, we can multiply the intensity ([0..1]) and the light drop-off ([0..1]). Meaning that a lower light intensity would increase the drop-off, making it harder for the light to propagate.\nConclusion I thought that a light system would be a very shader intensive task but with the light map texture trick, a 2D block lighting system can be easily implemented with just a queue and a bunch of multiplications.\nIt is also important to say that none of those light calculations are happening in the same thread of the game, as games require its main thread to run as fast as possible (in order to update and draw correctly).\n","date":"27","image":"/images/posts/i.imgur.com_2OprBJL.png","permalink":"http://localhost:8080/blog/2021-09-27_lighting_system/","tags":["lights","visual"],"title":"Lighting system"},{"categories":["mysc"],"contents":"This post is about the init function in golang and how it can be used for package initialization, avoiding filling the main function with initialization for each packet.\nBackground The necessity to initialize a packet before main function comes when trying to reduce the number of queries to zworld\u0026rsquo;s items database.\nThis database contains the information for all the items in the game, so it is easier to check, update and share the information t both the client and server.\nWhen implementing chicken nest block\u0026rsquo;s interaction, we had to:\n check if it was really that block change it to the empty version (without eggs) give the player the eggs collected  That means on every nest interaction, three queries will be performed.\nIt seems like it is just a few. But the current implementation of the find item from id name (\u0026ldquo;chicken_nest_eggs\u0026rdquo;, \u0026hellip;) is O(n) in the number of items, checking id by id comparing strings, so probably worse. This means a very bad performance when the items database grows.\nProposed Solution We couldn\u0026rsquo;t just create some globals, as the package initialization was being done in the main function, resulting in nil data when initializing the globals.\nThis is when Go\u0026rsquo;s init function comes handy. This function allows you to run code the first time the package is initialized. The order of this initialization is in import order, following recursively imports first. And, after all, the main function will be executed.\nBy initializing the items database package on the init function, we can allow any package importing the items database package to initialize globals, as the database will be already initialized.\nIt is a very handy (and unique, as most languages don\u0026rsquo;t have it) function and not so widely known.\n","date":"17","image":"/images/posts/i.imgur.com_z111iEy.png","permalink":"http://localhost:8080/blog/2021-09-17_golang_init_function/","tags":null,"title":"Golang init() function"},{"categories":["protocol"],"contents":"Client-server encryption and authentication based on Minecraft server.\nProtocol C: client\nS: server\nC → S: Login request Client requests the login process to start.\nS → C: Encryption request Server generates a random verify token.\nverifyToken := make([]byte, verifyTokenLength) rand.Read(verifyToken) Server also generates an unique random 16-byte token for authenticating ownership of client\u0026rsquo;s packets (once the login process has ended). The auth token won\u0026rsquo;t be encrypted, so the server knows the owner of each packet.\nServer sends his public key in PKIX, ASN.1 DER format.\nasn1PublicKey, _ := x509.MarshalPXIXPublicKey(global.PublicKey) C → S: Encryption response Client generates a shared 16-byte token used as symmetric key, that will be sent to the server encrypted with it\u0026rsquo;s public key. Client also encrypts the verify token.\nOnce this step is completed, the content of the packet will be encrypted using the symmetric key.\nThe server decrypts the shared secret and the verify token using its private key:\nsecret, _ := rsa.DecryptPKCS1v15(rand.Reader, global.PrivateKey, response.Secret) verifyToken, _ := rsa.DecryptPKCS1v15(rand.Reader, global.PrivateKey, response.VerifyToken) And then it compares the verify token:\nif bytes.Compare(token, verifyToken) != 0 { ... } // error C \u0026amp; S: Enable auth Both enable AES/CFB8 encryption using the shared secret token as both IV and key.\nblock, _ := aes.NewCipher(secret) conn.SetCipher( CFB8.NewCFB8Encrypt(block, secret), CFB8.NewCFB8Decrypt(block, secret), ) Questions  What if someone intercepts the auth token? Nothing would happen as the actual authority of packets is determined by the ability to encrypt the packets with the symmetric key. **Should authority be considered before login? **No, the encryption ensures the client who requested the connection is the one who is performing it, but unless he logs in, he can\u0026rsquo;t be the user he claims to be. **This authenticates the users, but does it authenticate the server? **No, and this should be considered in a future (). If server\u0026rsquo;s public distributio distributed by a trusted entity, clients could be fooled by a malicious server and steal client\u0026rsquo;s password.  ","date":"05","image":"/images/posts/i.imgur.com_zI8WrkR.png","permalink":"http://localhost:8080/blog/2021-09-05_client_authentication/","tags":null,"title":"Client authentication"}]